package main

import "fmt"

/*
切片原理

切片是Go语言在数组之上提供的一个重要的抽象数据类型。并且和数组相比，切片提供了更灵活、更高效的数据序列访问接口。​
*/

/*
先了解一下数组

Go语言数组是一个固定长度的、容纳同构类型元素的连续序列，因此Go数组类型具有两个属性：
元素类型和数组长度。这两个属性都相同的数组类型是等价的。比如以下变量a、b、c对应的数组类型是三个不同的数组类型
*/
func test1() {
	a := [8]int
	b := [8]byte
	c := [9]int
}

/*
Go数组是 值语义 的，这意味着一个数组变量表示的是 整个数组 ，这点与C语言完全不同。
在C语言中，数组变量可视为指向数组第一个元素的指针。 而在Go语言中传递数组是纯粹的值拷贝，
对于元素类型长度较大或元素个数较多的数组，如果直接以数组类型参数传递到函数中会有不小的性能损耗。
这时很多人会使用数组指针类型来定义函数参数，然后将数组地址传进函数，
这样做的确可以避免性能损耗，但这是C语言的惯用法，在Go语言中，更地道的方式是使用切片。

切片之于数组就像是文件描述符之于文件。
在Go语言中，数组更多是“退居幕后”​，承担的是底层存储空间的角色；
而切片则走向“前台”​，为底层的存储（数组）打开了一个访问的“窗口”​​。

切片是数组的“描述符”
切片之所以能在函数参数传递时避免较大性能损耗，是因为它是“描述符”的特性，
切片这个描述符是固定大小的，无论底层的数组元素类型有多大，切片打开的窗口有多长。
type slice struct{
	array unsafe.Pointer
	len int
	cap int
}


s:=make([]byte,5)
如果没有在make中指定cap参数，那么cap = len
*/

func test2() {
	u := [10]byte{11, 12, 13, 14, 15, 16, 17, 18, 19, 20}
	s1 := u[1:5] //包含头，不包含尾
	s2 := u[6:9]
	s3 := u[3:7]
	s4 := s3[2:4] //也可以基于已有切片创建新的切片，称为切片的reslicing.并且新切片和原切片同样是共享底层数组的，通过新切片对数组的修改也会反应到原切片中。
}

/*
因为无论切片描述的底层数组有多大，切片作为参数传递带来的性能损耗都是很小且恒定的，甚至小到可以忽略不计。
结构就是runtime.slice
type slice struct{
	array unsafe.Pointer
	len int
	cap int
}
另外，切片可以提供比指针更为强大的功能，比如**下标访问**、**边界溢出校验**、**动态扩容**等。
*/

/*
动态扩容
*/

func test3() {
	var s []byte // s被赋予零值nil
	s.append(s, 1)
	//由于初值为零值，s这个描述符并没有绑定对应的底层数组。而经过append操作后，s显然已经绑定了属于它的底层数组。
	//为了方便查看切片是如何动态扩容的，我们打印出每次append操作后切片s的len和cap值
	var a []int
	a = append(a, 11)
	fmt.Println(len(a), cap(a)) // 1 1
	a = append(a, 12)
	fmt.Println(len(a), cap(a)) // 2 2
	a = append(a, 13)
	fmt.Println(len(a), cap(a)) // 3 4
	a = append(a, 14)
	fmt.Println(len(a), cap(a)) // 4 4
	a = append(a, 15)
	fmt.Println(len(a), cap(a)) // 5 8
	//可以看到切片s的len值是线性增长的，但cap值却呈现出不规则的变化, 默认是*2。
	/*
		这样的append操作有时会给Gopher带来一些困惑，比如通过语法u[low: high]形式进行数组切片化而创建的切片，
		一旦切片cap触碰到数组的上界，再对切片进行append操作，切片就会和原数组解除绑定。
		所以尽量避免对切片进行append操作。!!!
	*/
}

/*
append操作是一件利器，它让切片类型部分满足了“零值可用”的理念。
但从append的原理中我们也能看到重新分配底层数组并复制元素的操作代价还是挺大的，尤其是当元素较多的情况下。
那么如何减少或避免为过多内存分配和复制付出的代价呢？
一种有效的方法是根据切片的使用场景对切片的容量规模进行预估，
并在创建新切片时将预估出的切片容量数据以cap参数的形式传递给内置函数make
*/
